<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C O M B O B R E A K E R</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #0a0a0f;
            color: #00ff88;
            min-height: 100vh;
            display: flex;
        }

        /* Stats Panel */
        .stats-panel {
            width: 250px;
            background: #12121a;
            border-right: 2px solid #00ff88;
            padding: 20px;
            display: flex;
            flex-direction: column;
            position: fixed;
            top: 0;
            left: 0;
            height: 100vh;
            overflow-y: auto;
        }

        /* Offset chat panel for fixed stats */
        .chat-panel {
            margin-left: 250px;
        }

        .stats-panel h2 {
            text-align: center;
            margin-bottom: 20px;
            color: #00ff88;
            text-shadow: 0 0 10px #00ff8855;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #00ff8833;
        }

        .stat-label {
            color: #888;
        }

        .stat-value {
            color: #00ff88;
            font-weight: bold;
        }

        .hp-bar-container {
            margin-top: 20px;
            background: #1a1a2e;
            border: 1px solid #00ff88;
            border-radius: 4px;
            overflow: hidden;
        }

        .hp-bar {
            height: 24px;
            background: linear-gradient(90deg, #00ff88, #00cc66);
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .hp-text {
            color: #0a0a0f;
            font-weight: bold;
            font-size: 12px;
        }

        .xp-bar-container {
            margin-top: 10px;
            background: #1a1a2e;
            border: 1px solid #4488ff;
            border-radius: 4px;
            overflow: hidden;
        }

        .xp-bar {
            height: 16px;
            background: linear-gradient(90deg, #4488ff, #2266cc);
            transition: width 0.3s ease;
        }

        .xp-label {
            text-align: center;
            font-size: 11px;
            color: #4488ff;
            margin-top: 4px;
        }

        /* Chat Panel */
        .chat-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #0d0d14;
        }

        .chat-messages {
            flex: 1;
            padding: 20px;
            padding-bottom: 100px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .message {
            padding: 10px 15px;
            border-radius: 8px;
            max-width: 80%;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .message.system {
            background: none;
            border: none;
            color: #00ff88;
            align-self: center;
            max-width: 90%;
        }

        .message.systemblue {
            background: none;
            border: none;
            color: #0000ff;
            align-self: center;
            max-width: 90%;
        }

        .message.enemy {
            background: #2a1a1a;
            border-left: 3px solid #ff4444;
            color: #ff6666;
        }

        .message.player {
            background: #1a2a1a;
            border-left: 3px solid #00ff88;
            color: #00ff88;
            align-self: flex-end;
        }

        .message.battle {
            background: #1a1a2e;
            border-left: 3px solid #4488ff;
            color: #88aaff;
            font-style: italic;
        }

        .message.damage {
            background: #2a1a2a;
            border-left: 3px solid #ff44aa;
            color: #ff88cc;
        }

        .message.victory {
            background: #1a2a2a;
            border-left: 3px solid #00ffcc;
            color: #00ffcc;
            font-weight: bold;
        }

        .message.defeat {
            background: #2a1a1a;
            border-left: 3px solid #ff0000;
            color: #ff4444;
            font-weight: bold;
        }

        .message.levelup {
            background: #2a2a1a;
            border-left: 3px solid #ffdd00;
            color: #ffdd00;
            font-weight: bold;
            text-align: center;
        }

        /* Equipment Panel */
        .equipment-panel {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid #00ff8844;
        }

        .equipment-panel h4 {
            color: #00ff88;
            margin-bottom: 10px;
            font-size: 12px;
        }

        .equip-slot {
            margin-bottom: 8px;
        }

        .equip-slot label {
            display: block;
            font-size: 10px;
            color: #888;
            margin-bottom: 2px;
        }

        .equip-slot select {
            width: 100%;
            padding: 6px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            background: #1a1a2e;
            color: #00ff88;
            border: 1px solid #00ff8855;
            border-radius: 4px;
            cursor: pointer;
        }

        .equip-slot select:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .equip-slot select:focus {
            outline: none;
            border-color: #00ff88;
        }

        /* Action Panel */
        .action-panel {
            padding: 15px 0;
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 20px;
        }

        .action-btn {
            padding: 12px 20px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            font-weight: bold;
            border: 2px solid;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            width: 100%;
        }

        .action-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .action-btn.engage {
            background: #1a2a1a;
            border-color: #00ff88;
            color: #00ff88;
        }

        .action-btn.engage:hover:not(:disabled) {
            background: #00ff88;
            color: #0a0a0f;
            box-shadow: 0 0 20px #00ff8855;
        }

        .action-btn.retreat {
            background: #2a1a1a;
            border-color: #ff4444;
            color: #ff4444;
        }

        .action-btn.retreat:hover:not(:disabled) {
            background: #ff4444;
            color: #0a0a0f;
            box-shadow: 0 0 20px #ff444455;
        }

        /* Shop Panel */
        .shop-panel {
            display: none;
            flex-direction: column;
            gap: 8px;
            margin-top: 10px;
        }

        .shop-panel.visible {
            display: flex;
        }

        .shop-btn {
            padding: 10px 12px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            border: 1px solid #4488ff;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            background: #1a1a2e;
            color: #4488ff;
            text-align: left;
            width: 100%;
        }

        .shop-btn:hover:not(:disabled) {
            background: #4488ff;
            color: #0a0a0f;
            box-shadow: 0 0 15px #4488ff55;
        }

        .shop-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            border-color: #666;
            color: #666;
        }

        .shop-btn.leave {
            border-color: #888;
            color: #888;
            margin-top: 5px;
        }

        .shop-btn.leave:hover {
            background: #888;
            color: #0a0a0f;
        }

        .shop-cost {
            color: #ffdd00;
            font-weight: bold;
        }

        .shop-cost.affordable {
            color: #00ff88;
        }

        .timer-display {
            text-align: center;
            padding: 10px;
            color: #666;
            font-size: 12px;
        }

        .save-indicator {
            text-align: center;
            font-size: 10px;
            color: #00ff88;
            opacity: 0;
            transition: opacity 0.3s ease;
            margin-top: 5px;
        }

        .save-indicator.visible {
            opacity: 1;
        }

        /* Options Button */
        .options-btn {
            background: #1a1a2e;
            border: 1px solid #00ff8855;
            color: #00ff88;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            padding: 4px 10px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .options-btn:hover {
            background: #00ff88;
            color: #0a0a0f;
        }

        /* Save Slot Modal */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal-overlay.visible {
            display: flex;
        }

        .modal {
            background: #12121a;
            border: 2px solid #00ff88;
            border-radius: 8px;
            padding: 20px;
            width: 420px;
            max-width: 90vw;
        }

        .modal h3 {
            color: #00ff88;
            text-align: center;
            margin-bottom: 15px;
        }

        .save-slot {
            background: #1a1a2e;
            border: 1px solid #00ff8833;
            border-radius: 4px;
            padding: 12px;
            margin-bottom: 10px;
        }

        .save-slot-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .save-slot-title {
            color: #00ff88;
            font-weight: bold;
            font-size: 13px;
        }

        .save-slot-info {
            color: #888;
            font-size: 11px;
            line-height: 1.6;
        }

        .save-slot-info span {
            color: #00ff88;
        }

        .save-slot-empty {
            color: #555;
            font-size: 11px;
            font-style: italic;
        }

        .save-slot-actions {
            display: flex;
            gap: 6px;
            margin-top: 8px;
        }

        .slot-btn {
            font-family: 'Courier New', monospace;
            font-size: 10px;
            padding: 4px 10px;
            border-radius: 3px;
            border: 1px solid;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .slot-btn.save {
            background: #1a2a1a;
            border-color: #00ff88;
            color: #00ff88;
        }

        .slot-btn.save:hover {
            background: #00ff88;
            color: #0a0a0f;
        }

        .slot-btn.load {
            background: #1a1a2e;
            border-color: #4488ff;
            color: #4488ff;
        }

        .slot-btn.load:hover {
            background: #4488ff;
            color: #0a0a0f;
        }

        .slot-btn.delete {
            background: #2a1a1a;
            border-color: #ff4444;
            color: #ff4444;
        }

        .slot-btn.delete:hover {
            background: #ff4444;
            color: #0a0a0f;
        }

        .slot-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .modal-close {
            display: block;
            width: 100%;
            margin-top: 10px;
            padding: 8px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            background: #1a1a2e;
            border: 1px solid #888;
            color: #888;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .modal-close:hover {
            background: #888;
            color: #0a0a0f;
        }

        /* Scrollbar */
        .chat-messages::-webkit-scrollbar {
            width: 8px;
        }

        .chat-messages::-webkit-scrollbar-track {
            background: #12121a;
        }

        .chat-messages::-webkit-scrollbar-thumb {
            background: #00ff8855;
            border-radius: 4px;
        }

        .chat-messages::-webkit-scrollbar-thumb:hover {
            background: #00ff88;
        }
    </style>
</head>
<body>
    <div class="stats-panel">
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <h3>[ COMBOBREAKER ]</h3>
            <button class="options-btn" id="btn-options">Options</button>
        </div>
        <h4>v1.5.0</h4>

        <div class="hp-bar-container">
            <div class="hp-bar" id="hp-bar">
                <span class="hp-text" id="hp-text">100 / 100</span>
            </div>
        </div>

        <div class="xp-bar-container">
            <div class="xp-bar" id="xp-bar" style="width: 0%"></div>
        </div>
        <div class="xp-label" id="xp-label">XP: 0 / 10</div>

        <div style="margin-top: 20px;">
            <div class="stat-row">
                <span class="stat-label">Level</span>
                <span class="stat-value" id="stat-level">1</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Attack</span>
                <span class="stat-value" id="stat-attack">5</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Speed</span>
                <span class="stat-value" id="stat-speed">10</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Defence</span>
                <span class="stat-value" id="stat-defence">3</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Combo</span>
                <span class="stat-value" id="stat-combo">5%</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Deaths</span>
                <span class="stat-value" id="stat-deaths">0</span>
            </div>
        </div>

        <div class="timer-display" id="timer-display">
            Next  in: --:--
        </div>
        <div class="save-indicator" id="save-indicator">
            [SAVED]
        </div>

        <div class="equipment-panel">
            <h4>[ INSTALLATIONS ]</h4>
            <div class="equip-slot">
                <label>Body</label>
                <select id="equip-body"><option value="">-- None --</option></select>
            </div>
            <div class="equip-slot">
                <label>Legs</label>
                <select id="equip-legs"><option value="">-- None --</option></select>
            </div>
            <div class="equip-slot">
                <label>Arms</label>
                <select id="equip-arms"><option value="">-- None --</option></select>
            </div>
            <div class="equip-slot">
                <label>Weapon</label>
                <select id="equip-weapon"><option value="">-- None --</option></select>
            </div>
            <div class="equip-slot">
                <label>Systems Chip</label>
                <select id="equip-chip"><option value="">-- None --</option></select>
            </div>
        </div>

        <div class="action-panel">
            <button class="action-btn engage" id="btn-engage" disabled>Engage</button>
            <button class="action-btn retreat" id="btn-retreat" disabled>Decline</button>
        </div>

        <div class="shop-panel" id="shop-panel">
            <button class="shop-btn" id="shop-item-1" disabled>--</button>
            <button class="shop-btn" id="shop-item-2" disabled>--</button>
            <button class="shop-btn" id="shop-item-3" disabled>--</button>
            <button class="shop-btn leave" id="shop-leave">Buy Nothing</button>
        </div>
    </div>

    <div class="chat-panel">
        <div class="chat-messages" id="chat-messages">
            <!-- Messages appear here -->
            <div class="action-panel">   <!-- Edit by me -->
        </div>
    </div>

    <div class="modal-overlay" id="save-modal">
        <div class="modal">
            <h3>[ SAVE SLOTS ]</h3>
            <div class="save-slot" id="slot-1">
                <div class="save-slot-header">
                    <span class="save-slot-title">Slot 1</span>
                </div>
                <div class="save-slot-info" id="slot-1-info">
                    <span class="save-slot-empty">-- Empty --</span>
                </div>
                <div class="save-slot-actions">
                    <button class="slot-btn save" onclick="saveToSlot(1)">Save</button>
                    <button class="slot-btn load" id="slot-1-load" onclick="loadFromSlot(1)" disabled>Load</button>
                    <button class="slot-btn delete" id="slot-1-delete" onclick="deleteSlot(1)" disabled>Delete</button>
                </div>
            </div>
            <div class="save-slot" id="slot-2">
                <div class="save-slot-header">
                    <span class="save-slot-title">Slot 2</span>
                </div>
                <div class="save-slot-info" id="slot-2-info">
                    <span class="save-slot-empty">-- Empty --</span>
                </div>
                <div class="save-slot-actions">
                    <button class="slot-btn save" onclick="saveToSlot(2)">Save</button>
                    <button class="slot-btn load" id="slot-2-load" onclick="loadFromSlot(2)" disabled>Load</button>
                    <button class="slot-btn delete" id="slot-2-delete" onclick="deleteSlot(2)" disabled>Delete</button>
                </div>
            </div>
            <div class="save-slot" id="slot-3">
                <div class="save-slot-header">
                    <span class="save-slot-title">Slot 3</span>
                </div>
                <div class="save-slot-info" id="slot-3-info">
                    <span class="save-slot-empty">-- Empty --</span>
                </div>
                <div class="save-slot-actions">
                    <button class="slot-btn save" onclick="saveToSlot(3)">Save</button>
                    <button class="slot-btn load" id="slot-3-load" onclick="loadFromSlot(3)" disabled>Load</button>
                    <button class="slot-btn delete" id="slot-3-delete" onclick="deleteSlot(3)" disabled>Delete</button>
                </div>
            </div>
            <button class="modal-close" id="modal-close">Close</button>
        </div>
    </div>

    <script src="enemies.js"></script>
    <script src="items.js"></script>
    <script src="encounters.js"></script>
    <script>
        // Game State
        const game = {
            player: {
                // Base stats (without equipment)
                baseMaxHp: 100,
                baseAttack: 5,
                baseSpeed: 10,
                baseDefence: 3,
                baseCombo: 5,
                // Current stats (with equipment)
                level: 1,
                xp: 0,
                xpToLevel: 10,
                maxHp: 100,
                hp: 100,
                attack: 5,
                speed: 10,
                defence: 3,
                combo: 5
            },
            // Inventory: array of item objects
            inventory: [],
            // Equipped items by slot (stores item name or null)
            equipment: {
                body: null,
                legs: null,
                arms: null,
                weapon: null,
                chip: null
            },
            currentWave: null,
            inBattle: false,
            battleInterval: null,
            regenInterval: null,
            waveTimer: null,
            nextWaveTime: 0,
            waveExpireTimer: null,
            WAVE_INTERVAL: 5000, // 5 seconds wait
            WAVE_EXPIRE: 30000, // 30 seconds to engage
            countdownInterval: null,
            countdownMsg: null,
            REGEN_RATE: 30000, // 1 hp per 30 seconds
            ENCOUNTER_CHANCE: 20, // % chance for encounter instead of enemy wave
            deaths: 0
        };

        // Current encounter state
        let currentEncounter = null;
        let shopItems = [];

        const SAVE_KEY = 'combobreaker_save';
        const SLOT_KEYS = ['combobreaker_slot_1', 'combobreaker_slot_2', 'combobreaker_slot_3'];

        // Build save data object from current game state
        function buildSaveData() {
            return {
                version: '1.1.0',
                player: {
                    level: game.player.level,
                    xp: game.player.xp,
                    xpToLevel: game.player.xpToLevel,
                    baseMaxHp: game.player.baseMaxHp,
                    baseAttack: game.player.baseAttack,
                    baseSpeed: game.player.baseSpeed,
                    baseDefence: game.player.baseDefence,
                    baseCombo: game.player.baseCombo
                },
                inventory: game.inventory.map(item => item.name),
                equipment: { ...game.equipment },
                deaths: game.deaths
            };
        }

        // Get slot data from localStorage (returns parsed object or null)
        function getSlotData(slotNum) {
            try {
                const raw = localStorage.getItem(SLOT_KEYS[slotNum - 1]);
                return raw ? JSON.parse(raw) : null;
            } catch (e) {
                return null;
            }
        }

        // Refresh all slot displays in the modal
        function refreshSlotDisplays() {
            for (let i = 1; i <= 3; i++) {
                const data = getSlotData(i);
                const infoEl = document.getElementById(`slot-${i}-info`);
                const loadBtn = document.getElementById(`slot-${i}-load`);
                const deleteBtn = document.getElementById(`slot-${i}-delete`);

                if (data && data.player) {
                    const p = data.player;
                    infoEl.innerHTML =
                        `Level: <span>${p.level || 1}</span> | ` +
                        `HP: <span>${p.baseMaxHp || 100}</span> | ` +
                        `ATK: <span>${p.baseAttack || 5}</span> | ` +
                        `SPD: <span>${p.baseSpeed || 10}</span> | ` +
                        `DEF: <span>${p.baseDefence || 3}</span><br>` +
                        `Combo: <span>${p.baseCombo || 5}%</span> | ` +
                        `Deaths: <span>${data.deaths || 0}</span> | ` +
                        `Items: <span>${(data.inventory || []).length}</span>`;
                    loadBtn.disabled = false;
                    deleteBtn.disabled = false;
                } else {
                    infoEl.innerHTML = '<span class="save-slot-empty">-- Empty --</span>';
                    loadBtn.disabled = true;
                    deleteBtn.disabled = true;
                }
            }
        }

        // Save current game to a slot
        function saveToSlot(slotNum) {
            try {
                localStorage.setItem(SLOT_KEYS[slotNum - 1], JSON.stringify(buildSaveData()));
                refreshSlotDisplays();
            } catch (e) {
                console.error('Failed to save to slot:', e);
            }
        }

        // Load game from a slot
        function loadFromSlot(slotNum) {
            const data = getSlotData(slotNum);
            if (!data || !data.player) return;

            // Restore player base stats
            game.player.level = data.player.level || 1;
            game.player.xp = data.player.xp || 0;
            game.player.xpToLevel = data.player.xpToLevel || 10;
            game.player.baseMaxHp = data.player.baseMaxHp || 100;
            game.player.baseAttack = data.player.baseAttack || 5;
            game.player.baseSpeed = data.player.baseSpeed || 10;
            game.player.baseDefence = data.player.baseDefence || 3;
            game.player.baseCombo = data.player.baseCombo || 5;

            game.deaths = data.deaths || 0;

            // Restore inventory
            game.inventory = [];
            if (data.inventory && Array.isArray(data.inventory)) {
                data.inventory.forEach(itemName => {
                    const item = ITEMS.find(i => i.name === itemName);
                    if (item) game.inventory.push(item);
                });
            }

            // Restore equipment
            if (data.equipment) {
                game.equipment = {
                    body: data.equipment.body || null,
                    legs: data.equipment.legs || null,
                    arms: data.equipment.arms || null,
                    weapon: data.equipment.weapon || null,
                    chip: data.equipment.chip || null
                };
            }

            recalculateStats();
            game.player.hp = game.player.maxHp;
            updateEquipmentUI();
            updateStats();
            saveGame();

            // Close modal and notify
            document.getElementById('save-modal').classList.remove('visible');
            addMessage(`[SLOT ${slotNum} LOADED] Level ${game.player.level} restored.`, 'system');
        }

        // Delete a save slot
        function deleteSlot(slotNum) {
            localStorage.removeItem(SLOT_KEYS[slotNum - 1]);
            refreshSlotDisplays();
        }

        // Save game state to localStorage
        function saveGame() {
            const saveData = buildSaveData();

            try {
                localStorage.setItem(SAVE_KEY, JSON.stringify(saveData));
                showSaveIndicator();
            } catch (e) {
                console.error('Failed to save game:', e);
            }
        }

        // Load game state from localStorage
        function loadGame() {
            try {
                const savedData = localStorage.getItem(SAVE_KEY);
                if (!savedData) return false;

                const data = JSON.parse(savedData);

                // Restore player base stats and progression
                game.player.level = data.player.level || 1;
                game.player.xp = data.player.xp || 0;
                game.player.xpToLevel = data.player.xpToLevel || 10;
                game.player.baseMaxHp = data.player.baseMaxHp || 100;
                game.player.baseAttack = data.player.baseAttack || 5;
                game.player.baseSpeed = data.player.baseSpeed || 10;
                game.player.baseDefence = data.player.baseDefence || 3;
                game.player.baseCombo = data.player.baseCombo || 5;

                // Restore death counter
                game.deaths = data.deaths || 0;

                // Restore inventory (convert names back to item objects)
                game.inventory = [];
                if (data.inventory && Array.isArray(data.inventory)) {
                    data.inventory.forEach(itemName => {
                        const item = ITEMS.find(i => i.name === itemName);
                        if (item) {
                            game.inventory.push(item);
                        }
                    });
                }

                // Restore equipment
                if (data.equipment) {
                    game.equipment = {
                        body: data.equipment.body || null,
                        legs: data.equipment.legs || null,
                        arms: data.equipment.arms || null,
                        weapon: data.equipment.weapon || null,
                        chip: data.equipment.chip || null
                    };
                }

                return true;
            } catch (e) {
                console.error('Failed to load game:', e);
                return false;
            }
        }

        // Show save indicator briefly
        function showSaveIndicator() {
            const indicator = document.getElementById('save-indicator');
            indicator.classList.add('visible');
            setTimeout(() => {
                indicator.classList.remove('visible');
            }, 1500);
        }

        // DOM Elements
        const chatMessages = document.getElementById('chat-messages');
        const btnEngage = document.getElementById('btn-engage');
        const btnRetreat = document.getElementById('btn-retreat');
        const timerDisplay = document.getElementById('timer-display');

        // Add message to chat with delay
        async function addMessage(text, type = 'system') {
            const msg = document.createElement('div');
            msg.className = `message ${type}`;
            msg.textContent = text;
            chatMessages.appendChild(msg);
            msg.scrollIntoView({ behavior: 'smooth', block: 'end' });
            await new Promise(resolve => setTimeout(resolve, 800));
        }

        // Update UI
        function updateStats() {
            const p = game.player;

            // HP Bar
            const hpPercent = (p.hp / p.maxHp) * 100;
            document.getElementById('hp-bar').style.width = `${hpPercent}%`;
            document.getElementById('hp-text').textContent = `${p.hp} / ${p.maxHp}`;

            // XP Bar
            const xpPercent = (p.xp / p.xpToLevel) * 100;
            document.getElementById('xp-bar').style.width = `${xpPercent}%`;
            document.getElementById('xp-label').textContent = `XP: ${p.xp} / ${p.xpToLevel}`;

            // Stats
            document.getElementById('stat-level').textContent = p.level;
            document.getElementById('stat-attack').textContent = p.attack;
            document.getElementById('stat-speed').textContent = p.speed;
            document.getElementById('stat-defence').textContent = p.defence;
            document.getElementById('stat-combo').textContent = `${p.combo}%`;
            document.getElementById('stat-deaths').textContent = game.deaths;
        }

        // Recalculate stats from base + equipment
        function recalculateStats() {
            const p = game.player;
            const oldMaxHp = p.maxHp;

            // Start with base stats
            p.maxHp = p.baseMaxHp;
            p.attack = p.baseAttack;
            p.speed = p.baseSpeed;
            p.defence = p.baseDefence;
            p.combo = p.baseCombo;

            // Add equipment bonuses
            for (const slot in game.equipment) {
                const itemName = game.equipment[slot];
                if (itemName) {
                    const item = ITEMS.find(i => i.name === itemName);
                    if (item && item.stats) {
                        if (item.stats.hp) p.maxHp += item.stats.hp;
                        if (item.stats.attack) p.attack += item.stats.attack;
                        if (item.stats.speed) p.speed += item.stats.speed;
                        if (item.stats.defence) p.defence += item.stats.defence;
                        if (item.stats.combo) p.combo += item.stats.combo;
                    }
                }
            }

            // Adjust current HP if max HP changed
            if (p.maxHp > oldMaxHp) {
                p.hp += (p.maxHp - oldMaxHp);
            } else if (p.hp > p.maxHp) {
                p.hp = p.maxHp;
            }

            updateStats();
        }

        // Update equipment dropdowns with inventory items
        function updateEquipmentUI() {
            const slots = ['body', 'legs', 'arms', 'weapon', 'chip'];

            slots.forEach(slot => {
                const select = document.getElementById(`equip-${slot}`);
                const currentValue = game.equipment[slot] || '';

                // Clear and rebuild options
                select.innerHTML = '<option value="">-- None --</option>';

                // Add items from inventory that match this slot
                const slotItems = game.inventory.filter(item => item.type === slot);
                slotItems.forEach(item => {
                    const option = document.createElement('option');
                    option.value = item.name;
                    option.textContent = item.name;
                    if (item.name === currentValue) {
                        option.selected = true;
                    }
                    select.appendChild(option);
                });
            });
        }

        // Handle equipment change
        function onEquipmentChange(slot, itemName) {
            if (game.inBattle) return; // Can't change during battle

            game.equipment[slot] = itemName || null;
            recalculateStats();
            saveGame();
        }

        // Lock/unlock equipment dropdowns
        function setEquipmentLocked(locked) {
            const slots = ['body', 'legs', 'arms', 'weapon', 'chip'];
            slots.forEach(slot => {
                document.getElementById(`equip-${slot}`).disabled = locked;
            });
        }

        // Add item to inventory
        function addItemToInventory(item) {
            game.inventory.push(item);
            updateEquipmentUI();
            saveGame();
        }

        // Get random item drop from defeated enemy
        function getRandomItemDrop(enemyName) {
            // Filter items that can drop from this enemy
            const droppableItems = ITEMS.filter(item => {
                if (item.droppedBy.length === 0) return true; // Drops from any enemy
                return item.droppedBy.includes(enemyName);
            });

            if (droppableItems.length === 0) return null;

            // Calculate total drop rate
            const totalRate = droppableItems.reduce((sum, item) => sum + item.dropRate, 0);

            // Random selection
            let roll = Math.random() * totalRate;
            for (const item of droppableItems) {
                roll -= item.dropRate;
                if (roll <= 0) {
                    return item;
                }
            }

            return droppableItems[0];
        }

        // Level up check
        function checkLevelUp() {
            const p = game.player;
            if (p.xp >= p.xpToLevel) {
                p.xp -= p.xpToLevel;
                p.level++;
                p.xpToLevel = Math.floor(p.xpToLevel * 1.5);

                // Increase BASE stats
                p.baseMaxHp += 10;
                p.baseAttack += 2;
                p.baseSpeed += 3;
                p.baseDefence += 1;
                p.baseCombo = Math.min(p.baseCombo + 2, 50);

                // Recalculate with equipment and full heal
                recalculateStats();
                p.hp = p.maxHp;

                addMessage(`[LEVEL INCREASED TO ${p.level}]`, 'system');
                addMessage(`Stats gained: [ATK+2] [SPD+3] [DEF+1] [COMBO+2%] [MAX HP+10]`, 'system');
                updateStats();
                saveGame();

                // Check for another level up
                checkLevelUp();
            }
        }

        // Select enemy type based on player level and appearance rates
        function selectEnemyType() {
            const playerLevel = game.player.level;

            // Filter enemies by level requirement
            const available = ENEMIES.filter(e => e.minLevel <= playerLevel);

            // Calculate total appearance rate
            const totalRate = available.reduce((sum, e) => sum + e.appearanceRate, 0);

            // Random selection weighted by appearance rate
            let roll = Math.random() * totalRate;
            for (const enemy of available) {
                roll -= enemy.appearanceRate;
                if (roll <= 0) {
                    return enemy;
                }
            }

            // Fallback to first available
            return available[0];
        }

        // Generate enemy wave
        function generateWave() {
            const enemyType = selectEnemyType();
            const min = enemyType.squadMin || 1;
            const max = enemyType.squadMax || 1;
            const enemyCount = Math.floor(Math.random() * (max - min + 1)) + min;

            return {
                enemyType: enemyType,
                count: enemyCount,
                remaining: enemyCount,
                currentTarget: 1, // Which enemy we're fighting (1-indexed)
                currentEnemy: null, // Will hold current enemy's HP in battle
                turn: 0
            };
        }

        // Select encounter type based on player level and appearance rates
        function selectEncounterType() {
            const playerLevel = game.player.level;

            // Filter encounters by level requirement
            const available = ENCOUNTERS.filter(e => e.minLevel <= playerLevel);
            if (available.length === 0) return null;

            // Calculate total appearance rate
            const totalRate = available.reduce((sum, e) => sum + e.appearanceRate, 0);

            // Random selection weighted by appearance rate
            let roll = Math.random() * totalRate;
            for (const encounter of available) {
                roll -= encounter.appearanceRate;
                if (roll <= 0) {
                    return encounter;
                }
            }

            return available[0];
        }

        // Generate shop items based on encounter slot configuration
        function generateShopItems(encounter) {
            const items = [];
            const slots = [encounter.itemSlot1, encounter.itemSlot2, encounter.itemSlot3];
            const usedItems = new Set(); // Track used items to avoid duplicates

            for (let i = 0; i < 3; i++) {
                const slotConfig = slots[i] || [];
                let item = null;

                if (slotConfig.length > 0) {
                    // Pick randomly from the configured item names
                    const availableInSlot = slotConfig.filter(name => !usedItems.has(name));
                    if (availableInSlot.length > 0) {
                        const itemName = availableInSlot[Math.floor(Math.random() * availableInSlot.length)];
                        item = ITEMS.find(i => i.name === itemName);
                    }
                } else {
                    // Empty array = pick random from all items
                    const availableItems = ITEMS.filter(i => !usedItems.has(i.name));
                    if (availableItems.length > 0) {
                        item = availableItems[Math.floor(Math.random() * availableItems.length)];
                    }
                }

                if (item) {
                    usedItems.add(item.name);
                    items.push(item);
                } else {
                    items.push(null);
                }
            }

            return items;
        }

        // Update shop UI with current items
        function updateShopUI() {
            const playerXP = game.player.xp;

            for (let i = 0; i < 3; i++) {
                const btn = document.getElementById(`shop-item-${i + 1}`);
                const item = shopItems[i];

                if (item) {
                    const canAfford = playerXP >= item.cost;
                    const costClass = canAfford ? 'affordable' : '';
                    btn.innerHTML = `${item.name} <span class="shop-cost ${costClass}">[${item.cost} XP]</span>`;
                    btn.disabled = !canAfford;
                    btn.style.display = 'block';
                } else {
                    btn.style.display = 'none';
                }
            }
        }

        // Show shop panel
        function showShopPanel() {
            document.getElementById('shop-panel').classList.add('visible');
            document.querySelector('.action-panel').style.display = 'none';
            updateShopUI();
        }

        // Hide shop panel
        function hideShopPanel() {
            document.getElementById('shop-panel').classList.remove('visible');
            document.querySelector('.action-panel').style.display = 'flex';
        }

        // Handle shop purchase
        function purchaseItem(index) {
            const item = shopItems[index];
            if (!item || game.player.xp < item.cost) return;

            game.player.xp -= item.cost;
            addItemToInventory(item);
            addMessage(`Purchased: ${item.name} for ${item.cost} XP`, 'victory');
            updateStats();

            // Remove item from shop
            shopItems[index] = null;
            updateShopUI();
        }

        // End shop encounter
        function endShopEncounter() {
            hideShopPanel();
            currentEncounter = null;
            shopItems = [];
            addMessage(`Transaction complete. The trader departs.`, 'system');
            startWaveTimer();
        }

        // Spawn encounter
        function spawnEncounter() {
            const encounter = selectEncounterType();
            if (!encounter) return false;

            currentEncounter = encounter;
            shopItems = generateShopItems(encounter);

            addMessage(`[ENCOUNTER] ${encounter.name}`, 'system');
            addMessage(encounter.description, 'system');

            // Create countdown message
            let secondsLeft = Math.floor(game.WAVE_EXPIRE / 1000);
            const countdownMsg = document.createElement('div');
            countdownMsg.className = 'message system';
            countdownMsg.textContent = `Signal available for [${secondsLeft}] seconds.`;
            chatMessages.appendChild(countdownMsg);
            chatMessages.scrollTop = chatMessages.scrollHeight;
            game.countdownMsg = countdownMsg;

            // Update countdown every second
            game.countdownInterval = setInterval(() => {
                secondsLeft--;
                if (secondsLeft > 0) {
                    countdownMsg.textContent = `Signal available for [${secondsLeft}] seconds.`;
                } else {
                    clearCountdown();
                }
            }, 1000);

            btnEngage.disabled = false;
            btnRetreat.disabled = false;

            // Set expiration timer
            if (game.waveExpireTimer) clearTimeout(game.waveExpireTimer);
            game.waveExpireTimer = setTimeout(() => {
                clearCountdown();
                if (currentEncounter) {
                    addMessage(`Signal lost. The ${encounter.name} has moved on.`, 'system');
                    currentEncounter = null;
                    shopItems = [];
                    btnEngage.disabled = true;
                    btnRetreat.disabled = true;
                    startWaveTimer();
                }
            }, game.WAVE_EXPIRE);

            return true;
        }

        // Engage encounter (shop)
        async function engageEncounter() {
            if (!currentEncounter) return;

            // Clear expire timer and countdown
            if (game.waveExpireTimer) {
                clearTimeout(game.waveExpireTimer);
                game.waveExpireTimer = null;
            }
            clearCountdown();

            btnEngage.disabled = true;
            btnRetreat.disabled = true;

            await addMessage(currentEncounter.engageText, 'system');
            await addMessage(`Your XP: ${game.player.xp}`, 'system');

            showShopPanel();
        }

        // Decline encounter
        function declineEncounter() {
            if (!currentEncounter) return;

            // Clear expire timer and countdown
            if (game.waveExpireTimer) {
                clearTimeout(game.waveExpireTimer);
                game.waveExpireTimer = null;
            }
            clearCountdown();

            addMessage(`Encounter declined. Moving on.`, 'player');
            currentEncounter = null;
            shopItems = [];
            btnEngage.disabled = true;
            btnRetreat.disabled = true;
            startWaveTimer();
        }

        // Clear countdown timer
        function clearCountdown() {
            if (game.countdownInterval) {
                clearInterval(game.countdownInterval);
                game.countdownInterval = null;
            }
            if (game.countdownMsg) {
                game.countdownMsg.remove();
                game.countdownMsg = null;
            }
        }

        // Spawn new wave
        function spawnWave() {
            if (game.inBattle || game.currentWave || currentEncounter) return;

            // Check for encounter chance
            if (Math.random() * 100 < game.ENCOUNTER_CHANCE) {
                if (spawnEncounter()) return;
            }

            game.currentWave = generateWave();
            const et = game.currentWave.enemyType;
            addMessage(`[TARGET ACQUIRED]> ${game.currentWave.count} ${et.name}s are within engagement range [ATK:${et.attack} DEF:${et.defence} HP:${et.hp}]`, 'enemy');

            // Create countdown message
            let secondsLeft = Math.floor(game.WAVE_EXPIRE / 1000);
            const countdownMsg = document.createElement('div');
            countdownMsg.className = 'message system';
            countdownMsg.textContent = `Enemy location locked [${secondsLeft}] seconds until EMP signal jam.`;
            chatMessages.appendChild(countdownMsg);
            chatMessages.scrollTop = chatMessages.scrollHeight;
            game.countdownMsg = countdownMsg;

            addMessage(`Mech awaiting orders...`, 'player');

            // Update countdown every second
            game.countdownInterval = setInterval(() => {
                secondsLeft--;
                if (secondsLeft > 0) {
                    countdownMsg.textContent = `Enemy signal locked. [${secondsLeft}] seconds until signal loss.`;
                } else {
                    clearCountdown();
                }
            }, 1000);

            btnEngage.disabled = false;
            btnRetreat.disabled = false;

            // Set expiration timer
            if (game.waveExpireTimer) clearTimeout(game.waveExpireTimer);
            game.waveExpireTimer = setTimeout(() => {
                clearCountdown();
                if (game.currentWave && !game.inBattle) {
                    addMessage(`Signal lost. Scanning...`, 'system');
                    game.currentWave = null;
                    btnEngage.disabled = true;
                    btnRetreat.disabled = true;
                }
            }, game.WAVE_EXPIRE);
        }

        // Start wave timer
        function startWaveTimer() {
            game.nextWaveTime = Date.now() + game.WAVE_INTERVAL;

            if (game.waveTimer) clearInterval(game.waveTimer);

            game.waveTimer = setInterval(() => {
                const remaining = Math.max(0, game.nextWaveTime - Date.now());
                const minutes = Math.floor(remaining / 60000);
                const seconds = Math.floor((remaining % 60000) / 1000);
                timerDisplay.textContent = `Next wave in: ${minutes}:${seconds.toString().padStart(2, '0')}`;

                if (remaining <= 0) {
                    spawnWave();
                    startWaveTimer();
                }
            }, 1000);
        }

        // Player attack helper - calculates damage vs enemy defence
        function calculateDamage(attackStat, defenceStat) {
            const damage = Math.max(1, attackStat - defenceStat);
            return damage;
        }

        // Battle round - player attacks, then all enemies attack in sequence
        async function battleRound() {
            const p = game.player;
            const wave = game.currentWave;
            const et = wave.enemyType;

            if (!wave || wave.remaining <= 0 || p.hp <= 0) {
                endBattle();
                return;
            }

            // Spawn new enemy if needed
            if (wave.currentEnemy === null) {
                wave.currentEnemy = et.hp;
            }

            wave.turn++;
            await addMessage(`- - - - - - - - - - - - - - - - - - - - -[ Turn ${wave.turn} ]- - - - - - - - - - - - - - - - - - - - - `, 'system');

            // Determine attacks this turn
            let speedTriggered = Math.random() * 100 < p.speed;
            let comboTriggered = Math.random() * 100 < p.combo;
            let attackCount = speedTriggered ? 2 : 1;

            if (speedTriggered) {
                await addMessage(`[SPEEDBREAKER TRIGGERED]`, 'player');
            }
            if (comboTriggered) {
                await addMessage(`[COMBOBREAKER TRIGGERED]`, 'player');
            }

            // Calculate damage (combo applies to all attacks this turn)
            let playerDamage = calculateDamage(p.attack, et.defence);
            if (comboTriggered) {
                playerDamage *= 2;
            }

            // Perform attacks
            for (let atk = 1; atk <= attackCount; atk++) {
                // If current enemy is dead, target next one
                if (wave.currentEnemy === null) {
                    if (wave.remaining <= 0) {
                        endBattle(true);
                        return;
                    }
                    wave.currentEnemy = et.hp;
                }

                wave.currentEnemy -= playerDamage;
                await addMessage(`Mech attacks ${et.name} #${wave.currentTarget} for ${playerDamage} damage.`, 'player');

                // Check if current enemy 
                if (wave.currentEnemy <= 0) {
                    wave.remaining--;
                    wave.xpEarned = (wave.xpEarned || 0) + et.xp;
                    await addMessage(`[KILL CONFIRMED] ${et.name} #${wave.currentTarget} destroyed (+${et.xp} XP)`, 'enemy');
                    wave.currentTarget++;
                    wave.currentEnemy = null;

                    if (wave.remaining <= 0) {
                        endBattle(true);
                        return;
                    }
                } else {
                    await addMessage(`${et.name} #${wave.currentTarget} reduced to ${wave.currentEnemy} HP`, 'enemy');
                }
            }

            // All remaining enemies attack in sequence
            let remainingDefence = p.defence; // Defence pool for this turn

            for (let i = wave.currentTarget; i <= wave.count; i++) {
                await addMessage(`${et.name} #${i} attacks Mech for ${et.attack} damage.`, 'enemy');

                if (remainingDefence >= et.attack) {
                    // Fully blocked
                    remainingDefence -= et.attack;
                    await addMessage(` [Damage blocked] (${remainingDefence} defence remaining)`, 'player');
                } else if (remainingDefence > 0) {
                    // Partially blocked
                    const damageTaken = et.attack - remainingDefence;
                    await addMessage(`Remaining defence absorbs ${remainingDefence} damage, but ${damageTaken} damage is still taken.`, 'player');
                    remainingDefence = 0;
                    p.hp = Math.max(0, p.hp - damageTaken);
                    updateStats();
                } else {
                    // No defence left
                    p.hp = Math.max(0, p.hp - et.attack);
                    await addMessage(`Mech takes ${et.attack} damage.`, 'player');
                    updateStats();
                }

                // Check if player defeated
                if (p.hp <= 0) {
                    endBattle(false);
                    return;
                }
            }
        }

        // End battle
        function endBattle(victory = false) {
            game.inBattle = false;
            setEquipmentLocked(false); // Unlock equipment

            if (game.battleInterval) {
                clearInterval(game.battleInterval);
                game.battleInterval = null;
            }

            const wave = game.currentWave;
            const enemiesKilled = wave ? wave.count - wave.remaining : 0;
            const xpEarned = wave ? (wave.xpEarned || 0) : 0;
            const enemyType = wave ? wave.enemyType.name : null;

            if (victory) {
                addMessage(`[ All hostiles confirmed destroyed ]`, 'system');
                game.player.xp += xpEarned;
                addMessage(`Mech gained ${xpEarned} XP.`, 'system');

                // Drop random item
                if (enemyType) {
                    const droppedItem = getRandomItemDrop(enemyType);
                    if (droppedItem) {
                        addItemToInventory(droppedItem);
                        addMessage(`Mech found item: ${droppedItem.name} [${ITEM_TYPES[droppedItem.type]}]`, 'victory');
                    }
                }

                checkLevelUp();
            } else {
                game.deaths++;
                addMessage(`Your mech has been confirmed destroyed.`, 'system');
                addMessage(`Systems resetting.`, 'system');
                // Respawn with half HP
                game.player.hp = Math.floor(game.player.maxHp / 2);
            }

            game.currentWave = null;
            updateStats();
            startRegen();
            startWaveTimer();
        }

        // Start HP regeneration
        function startRegen() {
            if (game.regenInterval) clearInterval(game.regenInterval);

            game.regenInterval = setInterval(() => {
                if (game.inBattle) return;

                if (game.player.hp < game.player.maxHp) {
                    game.player.hp = Math.min(game.player.maxHp, game.player.hp + 1);
                    updateStats();
                } else {
                    clearInterval(game.regenInterval);
                    game.regenInterval = null;
                }
            }, game.REGEN_RATE);
        }

        // Utility delay
        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Engage battle
        async function engageBattle() {
            if (!game.currentWave || game.inBattle) return;

            // Clear expire timer and countdown
            if (game.waveExpireTimer) {
                clearTimeout(game.waveExpireTimer);
                game.waveExpireTimer = null;
            }
            clearCountdown();

            btnEngage.disabled = true;
            btnRetreat.disabled = true;
            game.inBattle = true;
            setEquipmentLocked(true); // Lock equipment during battle

            if (game.regenInterval) {
                clearInterval(game.regenInterval);
                game.regenInterval = null;
            }

            const et = game.currentWave.enemyType;
            await addMessage(`Engagement confirmed for ${game.currentWave.count} ${et.name}s!`, 'player');
            await addMessage(`> > >  C O M B A T  S T A R T  < < <`, 'system');

            // Battle loop
            async function runBattle() {
                while (game.inBattle && game.currentWave && game.currentWave.remaining > 0 && game.player.hp > 0) {
                    await battleRound();
                }
            }

            runBattle();
        }

        // Decline battle
        function declineBattle() {
            if (!game.currentWave || game.inBattle) return;

            // Clear expire timer and countdown
            if (game.waveExpireTimer) {
                clearTimeout(game.waveExpireTimer);
                game.waveExpireTimer = null;
            }
            clearCountdown();

            addMessage(`Engagement denied. Live to fight another day.`, 'player');
            game.currentWave = null;
            btnEngage.disabled = true;
            btnRetreat.disabled = true;
        }

        // Event listeners
        btnEngage.addEventListener('click', () => {
            if (currentEncounter) {
                engageEncounter();
            } else {
                engageBattle();
            }
        });
        btnRetreat.addEventListener('click', () => {
            if (currentEncounter) {
                declineEncounter();
            } else {
                declineBattle();
            }
        });

        // Options modal event listeners
        document.getElementById('btn-options').addEventListener('click', () => {
            refreshSlotDisplays();
            document.getElementById('save-modal').classList.add('visible');
        });
        document.getElementById('modal-close').addEventListener('click', () => {
            document.getElementById('save-modal').classList.remove('visible');
        });
        document.getElementById('save-modal').addEventListener('click', (e) => {
            if (e.target === e.currentTarget) {
                document.getElementById('save-modal').classList.remove('visible');
            }
        });

        // Shop button event listeners
        document.getElementById('shop-item-1').addEventListener('click', () => purchaseItem(0));
        document.getElementById('shop-item-2').addEventListener('click', () => purchaseItem(1));
        document.getElementById('shop-item-3').addEventListener('click', () => purchaseItem(2));
        document.getElementById('shop-leave').addEventListener('click', endShopEncounter);

        // Initialize game
        function init() {
            // Set up equipment dropdown event listeners
            const slots = ['body', 'legs', 'arms', 'weapon', 'chip'];
            slots.forEach(slot => {
                document.getElementById(`equip-${slot}`).addEventListener('change', (e) => {
                    onEquipmentChange(slot, e.target.value);
                });
            });

            // Load saved game if exists
            const saveLoaded = loadGame();
            if (saveLoaded) {
                // Recalculate stats with loaded equipment
                recalculateStats();
                // Set HP to max on load (fresh session)
                game.player.hp = game.player.maxHp;
            }

            updateEquipmentUI();

            addMessage(`============================================`, 'system');
            addMessage(`=== C O M B O B R E A K E R  O N L I N E ===`, 'system');
            addMessage(`============================================`, 'system');

            if (saveLoaded) {
                addMessage(`[SAVE DATA LOADED] Welcome back, Pilot 72632`, 'system');
                addMessage(`Level ${game.player.level} | XP: ${game.player.xp}/${game.player.xpToLevel} | ${game.inventory.length} items in inventory`, 'system');
            } else {
                addMessage(`Remote mech is ready for combat [Pilot 72632]`, 'system');
            }

            addMessage(``, 'system');
            addMessage(`[] Engagement Protocols Approved [Autopilot Deactivated] `, 'system');
            addMessage(`[K E Y //::X2Y***_***_***_***_***_LZ7`, 'system');
            addMessage(`BreakerPilot Command Key Accepted.`, 'system');
            addMessage(`Engagement commands now available. [Engage] or [Decline]`, 'system');
            updateStats();

            // Spawn first wave immediately for testing
            setTimeout(() => {
                spawnWave();
                startWaveTimer();
            }, 2000);
        }

        init();
    </script>
</body>
</html>































